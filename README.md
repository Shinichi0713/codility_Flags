# codility_Flags

```
配列A(整数Nで構成)。
近傍に比べて大きなpeakがある。
以下を満たすPを見つける
0 < P < N − 1 and A[P − 1] < A[P] > A[P + 1]
どれだけフラグがあるかを選択すること。
旗はK持っていくことが出来る。
任意の２つの旗の間の距離はK以上でないといけない。
配列の中のピークに対して、どれくらいフラグをつけられるかを返すこと
```

![image](https://github.com/Shinichi0713/codility_Flags/assets/61480734/46e0e01a-c0d0-4a05-98a3-152faa9c46ba)

ピークの距離がフラグの数以上となるように|P-Q|を選ぶ
→フラグの数マックスを求めるコードを作る

例題：
    A[0] = 1
    A[1] = 5
    A[2] = 3
    A[3] = 4
    A[4] = 3
    A[5] = 4
    A[6] = 1
    A[7] = 2
    A[8] = 3
    A[9] = 4
    A[10] = 6
    A[11] = 2
ピークが1,3,5,10に存在
フラグはピークにのみセットすることが出来る。
さらには、Kフラグを取得した場合、いずれの２つのフラグの距離もK以上でなくてはならない。
距離は、PとQのフラグの場合、|P-Q|で与えられる
上記例の場合、12個のデータがある。
4つのフラグを前提とすると、1、5、10の３か所のピークのみにフラグをおくことが出来る→最大3フラグまでおくことが可能

制約条件：
・Nは整数
・どの配列の要素も0～1,000,000,000


# 結果

![image](https://github.com/user-attachments/assets/a6cef76b-9e91-4a2b-a043-7438b5c40d39)

# binary searchとは

```
バイナリサーチ（Binary Search）は、ソートされた配列から特定の要素を効率的に見つけるためのアルゴリズムです。
このアルゴリズムは、以下の手順で動作します：

中央の要素を比較: 配列の中央の要素を選び、探している要素と比較します。
範囲を絞る: 探している要素が中央の要素よりも小さい場合、配列の左半分を対象にします。逆に、大きい場合は右半分を対象にします。
繰り返し: 上記の手順を繰り返し、範囲を絞り続けます。最終的に、要素が見つかるか、範囲がなくなるまで繰り返します。
この方法は、配列がソートされている場合に非常に効率的で、時間計算量は O(log n) です。つまり、要素の数が増えても、比較回数は対数的にしか増えません。
```

